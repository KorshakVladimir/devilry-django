<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='devilry-extjshelpers-SearchStringParser'>/** Parses values from a string into plain values and filters which is
</span> * compatible with our RESTful filters.
 * */
Ext.define('devilry.extjshelpers.SearchStringParser', {
    filterToStringTpl: Ext.create('Ext.XTemplate', '{field}:{comp}:{value}'),
    toStringTpl: Ext.create('Ext.XTemplate',
        '&lt;tpl if=&quot;type&quot;&gt;type:{type} &lt;/tpl&gt;',
        '&lt;tpl if=&quot;filters&quot;&gt;{filters} &lt;/tpl&gt;',
        '{query}'),
    config: {
        searchstring: undefined,
        pageSizeWithType: 10,
        pageSizeWithoutType: 3
    },

    constructor: function(config) {
        this.initConfig(config);
        this.query = &quot;&quot;;
        this.filters = [];
        this.type = undefined;
        this.parseSearchString();
        return this;
    },

    toString: function() {
        return Ext.String.trim(this.toStringTpl.apply({
            query: this.query,
            filters: this.filtersToString(),
            type: this.type
        }));
    },

    filtersToString: function() {
        var filterstring = &quot;&quot;;
        var me = this;
        Ext.each(this.filters, function(filter) {
            filterstring += me.filterToString(filter) + ' ';
        });
        return Ext.String.trim(filterstring);
    },

    filterToString: function(filter) {
        return this.filterToStringTpl.apply(filter);
    },

    isInt: function(value) {
        return !isNaN(parseInt(value));
    },

    parseFilter: function(filtersplit) {
        var filter = new Object();
        filter.field = filtersplit[0];
        if(filtersplit.length === 2) {
            filter.comp = 'exact';
            filter.value = filtersplit[1];
        } else {
            filter.comp = filtersplit[1];
            filter.value = filtersplit[2];
        }
        if(this.isInt(filter.value)) {
            filter.value = parseInt(filter.value);
        }
        this.filters.push(filter);
    },

    parseFilterIsh: function(filterstring) {
        var split = filterstring.split(':');
        var first = split[0].toLowerCase();
        if(first === 'type') {
            this.type = split[1];
        } else {
            this.parseFilter(split);
        }
    },

<span id='devilry-extjshelpers-SearchStringParser-method-parseSearchString'>    /**
</span>     * @private
     * Parse ``this.searchstring`` into:
     *
     *  ``this.filters``
     *      A filter list on the format used by Devilry.
     *      This goes into the ``filters`` parameter of
     *      a Devilry search. Set to ``undefined`` if no
     *      filters are found.
     *
     * ``this.query``
     *      Other values (all words not containing :). This goes
     *      into the ``query`` parameter of a Devilry search.
     *      Set to ``undefined if no query is found.
     *
     *  ``this.type``
     *      A special *filter* (type:mytype) which specifies that a search should
     *      be done for a specific type instead of on multiple types. Set to
     *      ``undefined`` if not found.
     */
    parseSearchString: function() {
        var split = this.searchstring.split(' ');
        var query = &quot;&quot;;
        var me = this;
        Ext.each(split, function(word) {
            if(word.indexOf(':') === -1) {
                query += word + ' ';
            } else {
                me.parseFilterIsh(word);
            }
        });
        this.query = query;
        //console.log(this.query);
        //console.log(this.filters);
    },

    applyPageSizeToStore: function(store) {
        if(this.type) {
            store.pageSize = this.pageSizeWithType;
        } else {
            store.pageSize = this.pageSizeWithoutType;
        }
    },

    applyToExtraParams: function(extraParams, shortcuts) {
        if(!extraParams) {
            extraParams = new Object();
        }
        if(this.query) {
            extraParams.query = this.query;
        }
        if(this.filters) {
            var localfilters;
            if(shortcuts) {
                localfilters = this.applyShortcuts(shortcuts);
            } else {
                localfilters = this.filters;
            }
            extraParams.filters = Ext.JSON.encode(localfilters);
        }
        return extraParams;
    },

<span id='devilry-extjshelpers-SearchStringParser-method-applyShortcuts'>    /**
</span>     * @private
     */
    applyShortcuts: function(shortcuts) {
        var localfilters = Ext.clone(this.filters);
        var me = this;
        Ext.each(this.filters, function(filter, index) {
            var fieldnameFromFilter = me.applyFirstMatchingShortcut(shortcuts, filter.field);
            if(fieldnameFromFilter) {
                localfilters[index].field = fieldnameFromFilter;
            }
            //console.log(localfilters[index].field);
        });
        return localfilters;
    },

<span id='devilry-extjshelpers-SearchStringParser-method-applyFirstMatchingShortcut'>    /**
</span>     * @private
     */
    applyFirstMatchingShortcut: function(shortcuts, fieldname) {
        var realFieldname = undefined;
        Ext.Object.each(shortcuts, function(shortcut, replacement) {
            var startswithShortcut = new RegExp(&quot;^&quot; + shortcut);
            if(fieldname.match(startswithShortcut)) {
                realFieldname = fieldname.replace(startswithShortcut, replacement);
                return false;
            }
        });
        return realFieldname;
    }
});
</pre>
</body>
</html>
